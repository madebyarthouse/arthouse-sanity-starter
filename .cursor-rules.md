# Cursor AI Rules for React Router Project

## Project Context

This is a React Router v7 project with TypeScript, Tailwind CSS, and modern tooling.

## Tech Stack

- React Router v7 with SSR
- React 19
- TypeScript (strict mode)
- Tailwind CSS v4
- Sanity CMS with Visual Editing
- Vite
- pnpm for package management
- ESLint for linting
- Prettier for code formatting

## Code Style Preferences

- Use TypeScript for all new files
- Use functional components with hooks
- Prefer arrow functions for components
- Use Tailwind CSS for styling
- Follow ESLint and Prettier configurations
- Use pnpm for package management commands

## File Organization

- Components in `/app/components/`
- Routes in `/app/routes/` (including API routes)
- Utilities in `/app/lib/`
- Sanity integration in `/app/sanity/`
  - Schemas in `/app/sanity/schema/`
  - Server loaders in `/app/sanity/loader.server.ts`
  - Preview logic in `/app/sanity/preview.ts`
  - Generated types in `/app/sanity/types.ts`
- Root layout in `/app/root.tsx`

## React Router Patterns

- Use loaders for data fetching with proper TypeScript types
- Implement proper error boundaries in components and routes
- Use nested routing when appropriate
- Follow React Router v7 conventions with file-based routing
- Leverage SSR for SEO and performance
- Use dynamic routes (e.g., `$id` params) for content pages

## Sanity CMS Patterns

- Define schemas using `defineType` and `defineField` in `/app/sanity/schema/`
- Use GROQ queries with proper TypeScript typing
- Implement visual editing with `useQuery` and `encodeDataAttribute`
- Use server-side `loadQuery` for SSR data fetching
- Handle preview mode with session-based authentication
- Structure queries for optimal performance and caching
- Use stega encoding for visual editing functionality

## Best Practices

### General Development

- Write semantic, accessible HTML
- Use proper TypeScript types and strict mode
- Implement proper error handling and boundaries
- Follow React best practices and hooks patterns
- Use modern ES6+ syntax
- Prefer composition over inheritance

### Sanity CMS Best Practices

- Always validate required fields in schemas
- Use descriptive titles and descriptions for content fields
- Implement proper preview configurations for schemas
- Keep GROQ queries focused and efficient
- Use proper perspective switching for draft vs published content
- Implement secure session handling for preview mode
- Add proper validation rules to schema fields

### Performance Considerations

- Use React.memo for expensive components
- Implement proper loading states for async data
- Optimize GROQ queries for minimal data fetching
- Leverage Sanity's CDN for image optimization
- Use proper caching strategies for static content

## Testing

### Component Testing

- Write tests for components and utilities
- Use React Testing Library patterns
- Test user interactions and edge cases
- Mock Sanity client for isolated testing

### Content Testing

- Test GROQ queries with sample data
- Validate schema field requirements
- Test preview mode functionality
- Ensure visual editing works correctly

## Performance & Optimization

### React Performance

- Use React.memo for expensive components
- Implement code splitting for routes
- Optimize bundle size with tree shaking
- Use proper loading states and suspense

### Sanity Performance

- Optimize GROQ queries for minimal data transfer
- Use projection to fetch only needed fields
- Implement proper caching for static content
- Leverage Sanity's built-in CDN for assets
- Use incremental static regeneration when possible
